{% extends 'layout.html' %}

{% block title %}얼굴 등록{% endblock title %}

{% block contents %}
<style>
    .face-registration-container {
        background-color: #fff;
        padding: 20px;
        max-width: 700px;
        margin: 50px auto;
        border-radius: 10px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
        text-align: center;
        min-height: 600px; /* 컨테이너 크기 고정 */
        display: flex;
        flex-direction: column;
        justify-content: center;
    }

    .btn-container {
        display: flex;
        justify-content: space-between;
        margin-top: 20px;
    }

    .video-container {
        position: relative;
        width: 100%;
        height: auto;
    }

    #webcam {
        width: 100%;
        border-radius: 10px;
    }

    canvas {
        position: absolute;
        top: 0;
        left: 0;
        z-index: 10;
        pointer-events: none;
    }

    .instructions, .angle-status, .progress-status {
        margin-top: 10px;
        font-size: 18px;
    }

    .hidden {
        display: none;
    }

    .completion-message {
        font-size: 24px;
        font-weight: bold;
        color: green;
        margin-top: 20px;
    }
</style>

<div class="face-registration-container">
    <div class="btn-container">
        <a href="{% url 'loginhome' %}" class="btn btn-secondary">취소</a>
        <a href="javascript:history.back()" class="btn btn-secondary">이전</a>
    </div>

    <h2>얼굴을 등록하세요</h2>

    <div class="video-container">
        <video id="webcam" autoplay></video>
        <canvas id="overlayCanvas"></canvas>
    </div>

    <div class="instructions" id="instructions">등록 시작 버튼을 눌러주세요</div>
    <div class="angle-status" id="angle-status"></div>
    <div class="progress-status" id="progress-status"></div>
    <div class="completion-status hidden" id="completion-status">얼굴 등록 완료!</div>
    <button id="startRegistrationButton" class="btn btn-primary">등록 시작</button>
    <button id="closeButton" class="btn btn-secondary hidden">닫기</button>
</div>

<form id="csrfForm" style="display:none;">
    {% csrf_token %}
</form>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
<script>
    const startButton = document.getElementById('startRegistrationButton');
    const closeButton = document.getElementById('closeButton');
    const webcamElement = document.getElementById('webcam');
    const instructionsElement = document.getElementById('instructions');
    const angleStatusElement = document.getElementById('angle-status');
    const progressStatusElement = document.getElementById('progress-status');
    const completionStatusElement = document.getElementById('completion-status');
    const canvasElement = document.getElementById('overlayCanvas');
    const canvasCtx = canvasElement.getContext('2d');

    let faceMesh, camera;
    let capturedImages = [];
    let capturedAngles = { yaw: [], pitch: [], roll: [] };
    let currentAngleType = 'yaw';
    let pitchOffset = 0;

    const desiredAngles = {
        yaw: [-60, -40, -20, 0, 20, 40, 60],
        pitch: [-30, -20, 20, 30],
        roll: [-60, -40, -20, 20, 40, 60]
    };

    startButton.addEventListener('click', startRegistration);
    closeButton.addEventListener('click', closeRegistration);

    function startRegistration() {
        startButton.style.display = 'none';

        faceMesh = new FaceMesh({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
        });

        faceMesh.setOptions({
            maxNumFaces: 1,
            refineLandmarks: true,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        faceMesh.onResults(onResults);

        camera = new Camera(webcamElement, {
            onFrame: async () => {
                await faceMesh.send({ image: webcamElement });
            },
            width: 640,
            height: 480
        });

        camera.start();
    }

    function onResults(results) {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
            const landmarks = results.multiFaceLandmarks[0];

            const noseTip = landmarks[1];
            const leftEye = landmarks[33];
            const rightEye = landmarks[263];
            const chinTip = landmarks[199];

            const yaw = calculateYaw(noseTip, chinTip);
            const pitch = calculatePitch(noseTip, chinTip);
            const roll = calculateRoll(leftEye, rightEye);

            if (checkAndCaptureAngle(yaw, pitch, roll)) {
                const capturedCount = capturedImages.length + 1;

                progressStatusElement.textContent = `${capturedCount}/17 완료`;
                angleStatusElement.textContent = `각도: ${currentAngleType.charAt(0).toUpperCase() + currentAngleType.slice(1)}(${eval(currentAngleType).toFixed(1)}) 인식`;

                const image = captureImageFromVideo(webcamElement);
                capturedImages.push(image);

                if (capturedImages.length === 17) {
                    displayCompletionMessage();
                }
            } else {
                instructionsElement.textContent = getInstructionMessage(yaw, pitch, roll);
            }
        }
    }

    function displayCompletionMessage() {
        // 모든 화면 요소 숨기기
        webcamElement.style.display = 'none';
        canvasElement.style.display = 'none';
        instructionsElement.style.display = 'none';
        angleStatusElement.style.display = 'none';
        progressStatusElement.style.display = 'none';
        completionStatusElement.classList.remove('hidden');
        completionStatusElement.textContent = "얼굴 등록이 완료되었습니다!";
        closeButton.classList.remove('hidden');  // 닫기 버튼 표시
        camera.stop();
    }

    function closeRegistration() {
        sendImagesToServer(capturedImages)
            .then(() => {
                window.location.href = "{% url 'loginhome' %}";  // 홈 화면으로 이동
            })
            .catch(error => {
                console.error("Error:", error);
            });
    }

    function captureImageFromVideo(videoElement) {
        const canvas = document.createElement('canvas');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
        return canvas.toDataURL('image/jpeg');
    }

    function sendImagesToServer(images) {
        const csrfTokenElement = document.querySelector('[name=csrfmiddlewaretoken]');
        const csrfToken = csrfTokenElement ? csrfTokenElement.value : '';

        return fetch("{% url 'faces:register_face' %}", {
            method: 'POST',
            headers: {
                'X-CSRFToken': csrfToken,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({ images: images })
        })
        .then(response => response.json())
        .then(data => {
            if (data.success) {
                console.log("임베딩이 성공적으로 저장되었습니다.");
            } else {
                throw new Error("임베딩 저장에 실패했습니다.");
            }
        });
    }

    function calculateYaw(noseTip, chinTip) {
        const normalVector = { x: noseTip.x - chinTip.x, y: noseTip.y - chinTip.y, z: noseTip.z - chinTip.z };
        let yaw = Math.atan2(normalVector.x, normalVector.z) * (180 / Math.PI);
        return yaw < 0 ? yaw + 180 : yaw - 180;
    }

    function calculatePitch(noseTip, chinTip) {
        const normalVector = { x: noseTip.x - chinTip.x, y: noseTip.y - chinTip.y, z: noseTip.z - chinTip.z };
        let pitch = Math.atan2(-normalVector.y, normalVector.z) * (180 / Math.PI);

        if (pitchOffset === 0) {
            pitchOffset = pitch;
        }
        return pitch - pitchOffset;
    }

    function calculateRoll(leftEye, rightEye) {
        let roll = Math.atan2(rightEye.y - leftEye.y, rightEye.x - leftEye.x) * (180 / Math.PI);
        return roll >= 90 ? roll - 180 : roll <= -90 ? roll + 180 : roll;
    }

    function checkAndCaptureAngle(yaw, pitch, roll) {
        let targetAngle;

        if (currentAngleType === 'yaw') {
            targetAngle = desiredAngles.yaw[capturedAngles.yaw.length];
            if (Math.abs(yaw - targetAngle) < 10) {
                capturedAngles.yaw.push(yaw);
                if (capturedAngles.yaw.length === desiredAngles.yaw.length) currentAngleType = 'pitch';
                return true;
            }
        } else if (currentAngleType === 'pitch') {
            targetAngle = desiredAngles.pitch[capturedAngles.pitch.length];
            if (Math.abs(pitch - targetAngle) < 10) {
                capturedAngles.pitch.push(pitch);
                if (capturedAngles.pitch.length === desiredAngles.pitch.length) currentAngleType = 'roll';
                return true;
            }
        } else if (currentAngleType === 'roll') {
            targetAngle = desiredAngles.roll[capturedAngles.roll.length];
            if (Math.abs(roll - targetAngle) < 10) {
                capturedAngles.roll.push(roll);
                return true;
            }
        }
        return false;
    }

    function getInstructionMessage(yaw, pitch, roll) {
        let instruction = "얼굴을 ";

        if (currentAngleType === 'yaw') {
            const targetYaw = desiredAngles.yaw[capturedAngles.yaw.length];
            instruction += yaw > targetYaw ? "왼쪽으로 돌리세요." : "오른쪽으로 돌리세요.";
        } else if (currentAngleType === 'pitch') {
            const targetPitch = desiredAngles.pitch[capturedAngles.pitch.length];
            instruction += pitch > targetPitch ? "위로 올리세요." : "아래로 내리세요.";
        } else if (currentAngleType === 'roll') {
            const targetRoll = desiredAngles.roll[capturedAngles.roll.length];
            instruction += roll > targetRoll ? "오른쪽으로 갸우뚱하세요." : "왼쪽으로 갸우뚱하세요.";
        }

        return instruction;
    }
</script>

{% endblock contents %}
